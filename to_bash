# Git Configuration Functions
# Function to insert name and email into Git global config
gtc() {
    git config --global user.name "$gituser"
    git config --global user.email "$gitmail"
    echo "Git global configuration set to Name: $gituser, Email: $gitmail"
}

# Clone a GitHub repository using a personal access token
gcl() {
    git clone https://$token@github.com/$gituser/$1.git
    cd $1
}

# Echo Functions
# Echo content into a file (overwrite)
e() {
    echo "$1" > "$2"
}

# Echo content into a file (append)
ea() {
    echo "$1" >> "$2"
}

# Git Add, Commit, and Push
# Pull, add all changes, commit with a message, and push
g() {
    git pull
    git add .
    git commit -m "$*"
    git push
}

# Directory Management
# Create a directory and change into it
m() {
    mkdir -v -p $1
    cd $1
}

# Directory Navigation
# Function to navigate directories using dir_navigator.sh
re() {
    if [ "$#" -eq 1 ]; then
        # Use the provided path number as an argument and change directory
        eval "$(dir_navigator.sh "$1")"
    else
        while true; do
            # Display directory history
            dir_navigator.sh

            # Prompt the user
            echo "Enter a number to change directory, 'c' to clear history, 'd' to delete, or 'q' to quit."
            read choice

            if [ "$choice" == "q" ]; then
                break
            elif [ "$choice" == "c" ]; then
                echo "" > ~/.dir_history
            elif [ "$choice" == "d" ]; then
                # Request user input for paths to delete
                echo "Enter the numbers of paths to delete (separated by space), or 'q' to quit:"
                read delete_choices

                if [ "$delete_choices" == "q" ]; then
                    break
                else
                    # Reverse ~/.dir_history in a temp file
                    tac "$DIR_HISTORY_FILE" > "$DIR_HISTORY_FILE.tmp"

                    # Delete the selected lines
                    IFS=" " read -ra delete_numbers <<< "$delete_choices"
                    delete_numbers=($(echo "${delete_numbers[@]}" | tr ' ' '\n' | sort -nr))
                    for num in "${delete_numbers[@]}"; do
                        sed -i "${num}d" "$DIR_HISTORY_FILE.tmp"
                    done

                    # Reverse the temp file again before updating ~/.dir_history
                    tac "$DIR_HISTORY_FILE.tmp" > "$DIR_HISTORY_FILE"

                    # Remove the temporary file
                    rm "$DIR_HISTORY_FILE.tmp"
                fi
            else
                # Use the choice as an argument and change directory
                eval "$(dir_navigator.sh "$choice")"
                break
            fi
        done
    fi
}

# Function to clean up directory history
cleanup_dir_history() {
    wait

    # Read the file from the end, remove duplicates, and update the history file
    tac "$DIR_HISTORY_FILE" | awk '!seen[$0]++' | tac > "$DIR_HISTORY_FILE.tmp"
    mv "$DIR_HISTORY_FILE.tmp" "$DIR_HISTORY_FILE"
}

export DIR_HISTORY_FILE="$HOME/.dir_history"

# Override the cd command to append the new directory to the history file
cd() {
    builtin cd "$@" && echo "$PWD" >> "$DIR_HISTORY_FILE"
}

# File Creation and Opening
# Function to touch files and open them with VS Code
code='code'
t() {
    if [[ "$#" -eq 1 && ("$1" == "." || "$1" == "./") ]]; then
        $code .
    else
        for file in "$@"; do
            # Create the file
            touch "$file"
            # Open the file with VS Code
            $code "$file"
            # If the file ends with .sh, make it executable
            if [[ "$file" == *.sh ]]; then
                chmod +x "$file"
            fi
        done
    fi
}

# Basic Aliases
# Clone a repository and change into its directory
clone_repo() {
    git clone $1
    cd $1
}

# Update and clean the system
bfix() {
    sudo apt-get update
    sudo apt-get upgrade
    sudo apt-get dist-upgrade
    sudo apt-get autoremove
    sudo apt-get autoclean
}


## servers functions
### migsql is a function to backup a database and send to server
migsql() {
    # If arguments are not provided, prompt for input
    if [ -z "$1" ]; then
        read -p "Enter database user: " db_user
    else
        db_user=$1
    fi

    if [ -z "$2" ]; then
        read -p "Enter database name: " db_name
    else
        db_name=$2
    fi

    if [ -z "$3" ]; then
        read -p "Enter server username: " server_user
    else
        server_user=$3
    fi

    if [ -z "$4" ]; then
        read -p "Enter server name: " server_name
    else
        server_name=$4
    fi

    if [ -z "$5" ]; then
        read -p "Enter path to dump: " dump_path
    else
        dump_path=$5
    fi

    # Dump the database
    mysqldump -u "$db_user" -p --opt "$db_name" > "${db_name}.sql"

    # Transfer the dump to the server
    scp "${db_name}.sql" "${server_user}@${server_name}:${dump_path}"

    echo "Database dump and transfer complete."
}

# add a permanent swap file
sp() {
    if [ -z "$1" ]; then
        echo "Usage: sp <size-in-GB>"
        return 1
    fi

    # Check if the argument is a positive integer
    if ! [[ "$1" =~ ^[0-9]+$ ]]; then
        echo "Error: The size must be a positive integer."
        return 1
    fi

    # Define the size
    local size="${1}G"

    # Create the swap file
    sudo fallocate -l "$size" /swapfile

    # Set the correct permissions
    sudo chmod 600 /swapfile

    # Make the swap file
    sudo mkswap /swapfile

    # Enable the swap file
    sudo swapon /swapfile

    # Backup the fstab file
    sudo cp /etc/fstab /etc/fstab.bak

    # Add the swap file entry to /etc/fstab for persistence
    grep -q '/swapfile' /etc/fstab || echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab

    # Add sysctl parameters
    echo "
vm.swappiness=10
vm.vfs_cache_pressure=50
" | sudo tee -a /etc/sysctl.conf

    # Apply the new sysctl settings
    sudo sysctl -p

    echo "Swap file created, configured, and sysctl settings updated successfully."
}



alias cl="clone_repo"
alias bf="bfix"
alias q="python3"  # Launch Python 3 interpreter
alias ob='code ~/.bashrc'  # Open .bashrc in VS Code
alias sb='source ~/.bashrc'  # Reload .bashrc
alias h='history'  # Display command history
alias i='sudo apt-get install'  # Install a package
alias d='trash'  # Move files to trash
alias dd='sudo rm -rf /home/siroo/.local/share/Trash/files/*'  # Empty trash
alias cx='chmod +x'  # Make a file executable
alias xx='chmod -x'  # Make a file non-executable

# Go back to previous directories
alias b='cd ..'
alias bb='cd ../..'
alias b3='cd ../../../'
alias b4='cd ../../../../'
alias b5='cd ../../../../../'
alias b6='cd ../../../../../../'

# Git Aliases
alias ada='git add *'  # Add all files
alias ad='git add'  # Add specified files
alias gb='git branch'  # List branches
alias st='git status'  # Show the working tree status
alias gco='git checkout'  # Switch branches
alias gp='git push'  # Push changes
alias pl='git pull'  # Pull changes

# System Information Aliases
alias mem='free -m -t'  # Display memory usage
alias cpu='lscpu'  # Display CPU information
alias df='df -h'  # Display disk space usage in human-readable format
alias du='du -h'  # Display disk usage in human-readable format


#Auto completetion for bash shell for default user:

# Check if ble.sh is installed
if [ ! -d "$HOME/ble.sh" ]; then
    # Clone the repository and build ble.sh
    sudo apt install make
    cd ~
    mkdir tmp
    cd tmp
    git clone --recursive https://github.com/akinomyoga/ble.sh.git $HOME/ble.sh
    make -C $HOME/ble.sh
    cd ..
    rm -rf tmp
fi

# Source ble.sh
source $HOME/ble.sh/out/ble.sh



